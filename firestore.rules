/**
 * Core Philosophy: This ruleset establishes a secure environment for a lesson management application.
 * It operates on a "default deny" principle, where access is only granted explicitly. The model
 * prioritizes user privacy and administrative control. Authenticated users are the baseline for
 * any access.
 *
 * Data Structure: The database uses a flat, multi-collection structure. Core business entities
 * like `lessons`, `instructors`, `horses`, `students`, and `payments` are stored in their own
 * top-level collections. There are no user-specific root collections; instead, ownership and
 * access are determined by UID fields denormalized onto documents.
 *
 * Key Security Decisions:
 * 1. Admin-Managed Content: `instructors` and `horses` are treated as admin-configured data.
 *    While readable by any signed-in user to facilitate lesson booking, all write operations
 *    are disabled pending the implementation of a formal admin role system.
 * 2. Student Data Ownership: The `/students` collection uses a direct ownership model where the
 *    document ID must match the user's authentication UID. This ensures users can only create
 *    and manage their own student profile. Listing all students is prohibited.
 * 3. Relational Data Access: For `lessons` and `payments`, access is controlled by a denormalized
 *    `studentId` field. Only the user whose UID matches this field can read or modify the
 *    document, ensuring a student can only manage their own appointments and financial records.
 * 4. Flexible Queries: `list` operations on `lessons` and `payments` are permitted for any
 *    signed-in user, but the rules rely on the client application to correctly filter these
 *    queries to only request data for the current user (e.g., using a `where("studentId", "==", auth.uid)` clause).
 *    This supports application functionality while preventing unauthorized data leakage from the rules themselves.
 *
 * Denormalization for Authorization: This ruleset heavily relies on denormalization. The `studentId`
 * field is copied onto `Lesson` and `Payment` documents. This is critical for performance and security,
 * allowing for fast, direct authorization checks (e.g., `request.auth.uid == resource.data.studentId`)
 * without requiring slow and costly `get()` calls to other documents.
 *
 * Structural Segregation: Each data type resides in its own top-level collection. This clean
 * separation simplifies rule writing and makes security logic easier to reason about, as access
 * patterns do not overlap within a single collection path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the current user's UID matches the provided userId.
     * Used for direct ownership checks where the document ID is the user's UID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the document exists and if the current user is the owner.
     * Prevents modification or deletion of non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that the incoming document's studentId field
     * matches the currently authenticated user.
     */
    function isCreatingForSelf() {
      return request.resource.data.studentId == request.auth.uid;
    }

    /**
     * On update/delete, validates that the existing document's studentId
     * field matches the currently authenticated user.
     */
    function isDocumentStudent() {
      return request.auth.uid == resource.data.studentId;
    }
    
    /**
     * Enforces immutability of the studentId field on update.
     */
    function isStudentIdUnchanged() {
        return request.resource.data.studentId == resource.data.studentId;
    }
    
    function isManager() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'Manager';
    }

    function isInstructor() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'Instructor';
    }
    
    function isAdmin() {
        return isManager() || isInstructor();
    }


    /**
     * @description Rules for the 'lessons' collection.
     * @path /lessons/{lessonId}
     * @allow (get) A student (auth.uid: 'student123') can read a lesson where `studentId` is 'student123'.
     * @allow (create) A student (auth.uid: 'student123') can create a new lesson with `studentId: 'student123'`.
     * @deny (update) A student cannot change the `studentId` on an existing lesson document.
     * @deny (delete) A student (auth.uid: 'student456') cannot delete a lesson owned by 'student123'.
     * @principle Enforces that users can only manage lessons linked to their own student ID.
     */
    match /lessons/{lessonId} {
      allow get: if isSignedIn() && (isDocumentStudent() || isAdmin());
      allow list: if isSignedIn(); // Client MUST query with where("studentId", "==", request.auth.uid)
      allow create: if isSignedIn() && isCreatingForSelf();
      allow update: if isSignedIn() && (isDocumentStudent() || isAdmin()) && isStudentIdUnchanged() && resource != null;
      allow delete: if isSignedIn() && isDocumentStudent() && resource != null;
    }

    /**
     * @description Rules for the 'instructors' collection.
     * @path /instructors/{instructorId}
     * @allow (get, list) Any signed-in user can read instructor information to book a lesson.
     * @deny (create, update, delete) All write operations are denied, as this data should be managed by an administrator.
     * @principle Treats instructor data as publicly readable within the app but centrally managed.
     */
    match /instructors/{instructorId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isManager();
    }

    /**
     * @description Rules for the 'horses' collection.
     * @path /horses/{horseId}
     * @allow (get, list) Any signed-in user can read horse information to book a lesson.
     * @deny (create, update, delete) All write operations are denied, as this data should be managed by an administrator.
     * @principle Treats horse data as publicly readable within the app but centrally managed.
     */
    match /horses/{horseId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isManager();
    }

    /**
     * @description Rules for the 'students' collection.
     * @path /students/{studentId}
     * @allow (create) A new user (auth.uid: 'user123') can create their own student profile at `/students/user123`.
     * @allow (get) A user (auth.uid: 'user123') can read their own profile at `/students/user123`.
     * @deny (list) No user can list the entire `/students` collection.
     * @deny (update) A user (auth.uid: 'user456') cannot update the profile of 'user123'.
     * @principle Restricts access to a user's own data tree via path-based ownership.
     */
    match /students/{studentId} {
      allow get: if isOwner(studentId);
      allow list: if false; // Prevent users from listing all other students in the system.
      allow create: if isOwner(studentId) && request.resource.data.id == studentId;
      allow update: if isExistingOwner(studentId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(studentId);
    }

    /**
     * @description Rules for the 'payments' collection.
     * @path /payments/{paymentId}
     * @allow (get) A student (auth.uid: 'student123') can read a payment where `studentId` is 'student123'.
     * @allow (create) A student (auth.uid: 'student123') can create a new payment record with `studentId: 'student123'`.
     * @deny (update) A student cannot change the `studentId` on an existing payment document.
     * @deny (delete) A student (auth.uid: 'student456') cannot delete a payment for 'student123'.
     * @principle Enforces that users can only manage payments linked to their own student ID.
     */
    match /payments/{paymentId} {
      allow get: if isSignedIn() && isDocumentStudent();
      allow list: if isSignedIn(); // Client MUST query with where("studentId", "==", request.auth.uid)
      allow create: if isSignedIn() && isCreatingForSelf();
      allow update: if isSignedIn() && isDocumentStudent() && isStudentIdUnchanged() && resource != null;
      allow delete: if isSignedIn() && isDocumentStudent() && resource != null;
    }
    
    match /team-chat/{messageId} {
        allow read, write: if isAdmin();
    }

    match /availability/{availabilityId} {
        allow read, write: if isAdmin();
    }
    
    match /users/{userId} {
        allow read: if isSignedIn();
        allow create: if isOwner(userId);
        allow update: if isOwner(userId);
    }

    match /museumRentals/{rentalId} {
        allow create: if isSignedIn();
        allow read, list, update: if isManager();
    }
  }
}
